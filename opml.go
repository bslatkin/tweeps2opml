/*
 * Copyright 2014 Brett Slatkin
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package main

import (
	"log"
	"net/http"
	"net/url"
	"sync"
	"text/template"

	"github.com/bslatkin/tweeps2opml/disco"
)

var (
	opmlTemplate = template.Must(template.New("opml").Parse(`
<opml version="1.1">
    <!-- Generated by tweeps2opml -->
    <head>
        <title>Twitter Friends</title>
        <!-- TODO: Specify these dates -->
        <dateCreated>2014-12-27 18:50:30.579128</dateCreated>
        <dateModified>2014-12-27 18:50:30.579128</dateModified>
    </head>
    <body>
        <outline text="Twitter Friends" title="Twitter Friends">
        {{range .}}
            <outline htmlUrl="{{.ProfileURL}}" text="{{.ScreenName}} - {{.Title}}" title="{{.ScreenName}} - {{.Title}}" type="rss" xmlUrl="{{.URL.String}}" />
        {{end}}
        </outline>
    </body>
</opml>
`))
)

type DiscoveryResult struct {
	disco.Feed
	ScreenName string
	ProfileURL string
}

func discoverOne(screenName, profileUrl string, out chan<- DiscoveryResult, throttle chan int, wg *sync.WaitGroup) {
	defer wg.Done()

	token := <-throttle
	defer func() {
		throttle <- token
	}()

	parsed, err := url.Parse(profileUrl)
	if err != nil {
		log.Printf("Could not parse url=%s err=%s", profileUrl, err)
		return
	}

	feeds, err := disco.Discover(parsed)
	if err != nil {
		log.Printf("Could not discover url=%s err=%s", profileUrl, err)
		return
	}

	// TODO: Only pick one RSS or Atom feed
	// TODO: Skip obvious comment feeds
	// TODO: If ambiguous, pick the feed with the shortest URL
	// TODO: Don't output duplicates
	for _, result := range feeds {
		log.Printf("Discovered %s -> %s", screenName, result.URL.String())
		out <- DiscoveryResult{
			Feed:       result,
			ScreenName: screenName,
			ProfileURL: profileUrl,
		}
	}
}

func discoverParallel(out chan<- DiscoveryResult, friends map[string]string) {
	var wg sync.WaitGroup
	wg.Add(len(friends))

	// Limit the goroutines to N fetches in parallel
	throttle := make(chan int, 5)
	for i := 0; i < cap(throttle); i++ {
		throttle <- i
	}

	for screenName, profileUrl := range friends {
		go discoverOne(screenName, profileUrl, out, throttle, &wg)
	}

	wg.Wait()
	close(out)
}

func downloadHandler(w http.ResponseWriter, r *http.Request) {
	if err := r.ParseForm(); err != nil {
		log.Printf("Could not parse friend list: %s", err)
		http.Error(w, "Could not parse friend list", http.StatusBadRequest)
		return
	}

	friends := make(map[string]string, len(r.PostForm))
	for key, values := range r.PostForm {
		if len(values) == 1 {
			friends[key] = values[0]
		}
	}

	out := make(chan DiscoveryResult, len(r.PostForm))
	go discoverParallel(out, friends)

	w.Header().Set("Content-Disposition", "attachment; filename=twitter_friends.opml")
	w.Header().Set("Content-Type", "text/xml")
	opmlTemplate.Execute(w, out)
}
