package main

import (
	"fmt"
	"log"
	"net"
	"net/http"
	"net/url"
	"os"
	"sync"
	"text/template"

	"github.com/ChimeraCoder/anaconda"
	"github.com/bslatkin/tweeps2opml/disco"
	"github.com/gorilla/mux"
	"github.com/rodreegez/go-signin-with-twitter"
)

var (
	notAuthenticatedTemplate = template.Must(template.New("home").Parse(`
<html><body>
Generate an OPML file of my Twitter friends
<form action="/authorize" method="POST">
<input type="submit" value="Sign in to get started" />
<input type="hidden" name="continue" value="/generate" />
<input type="hidden" name="callback" value="/oauth_callback" />
</form>
</body></html>
`))
	friendsListTemplate = template.Must(template.New("friends").Parse(`
<html><body>
{{. | len}} friends
<form action="/download" method="POST" target="_blank">
{{range .}}
	{{if .URL}}
		<input name="{{.ScreenName}}" value="{{.URL}}" type="hidden" />
	{{end}}
{{end}}
<input type="submit" value="Download as OPML" />
</form>
</body></html>
`))
	opmlTemplate = template.Must(template.New("opml").Parse(`
<opml version="1.1">
    <!-- Generated by tweeps2opml -->
    <head>
        <title>Twitter Friends</title>
        <!-- TODO: Specify these dates -->
        <dateCreated>2014-12-27 18:50:30.579128</dateCreated>
        <dateModified>2014-12-27 18:50:30.579128</dateModified>
    </head>
    <body>
    	<outline text="Twitter Friends" title="Twitter Friends">
{{range .}}
	{{if not .Error}}
			<outline htmlUrl="{{.ProfileURL}}" text="{{.ScreenName}} - {{.Title}}" title="{{.ScreenName}} - {{.Title}}" type="rss" version="RSS" xmlUrl="{{.URL.String}}" />
	{{end}}
{{end}}
	    </outline>
    </body>
</opml>
`))
)

func homePageHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "text/html")
	notAuthenticatedTemplate.Execute(w, nil)
}

func listAllFriends(api *anaconda.TwitterApi) ([]anaconda.User, error) {
	result := make([]anaconda.User, 0, 1000)

	values := url.Values{}
	values.Set("cursor", "-1")
	values.Set("skip_status", "true")
	values.Set("include_user_entities", "false")
	values.Set("count", "200")

	// We're only allowed 15 requests every 15 minutes, so that's the most we'll even attempt to do. That means the most contacts you can export is 15 * 200 = 3000.
	for i := 0; i < 15; i++ {
		cursor, err := api.GetFriendsList(values)
		if err != nil {
			log.Printf("Could not list friends with arguments=%#v err=%s", values, err)
			return []anaconda.User{}, err
		}
		if len(cursor.Users) == 0 {
			break
		}
		result = append(result, cursor.Users...)
		values.Set("cursor", cursor.Next_cursor_str)
	}

	return result, nil
}

func generateHandler(w http.ResponseWriter, r *http.Request) {
	userInfo, err := signin.GetUserInfo(r)
	if userInfo == nil {
		if err != nil {
			log.Printf("Could not get access token: %s", err)
		}
		http.Redirect(w, r, "/", http.StatusFound)
		return
	}

	anaconda.SetConsumerKey(os.Getenv("TWITTER_KEY"))
	anaconda.SetConsumerSecret(os.Getenv("TWITTER_SECRET"))
	api := anaconda.NewTwitterApi(userInfo.Token, userInfo.Secret)

	allFriends, err := listAllFriends(api)
	if err != nil {
		http.Error(w, "Could not list friends", http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "text/html")
	friendsListTemplate.Execute(w, allFriends)
}

type DiscoveryResult struct {
	disco.Feed
	ScreenName string
	ProfileURL string
	Error      error
}

func discoverOne(screenName, profileUrl string, out chan<- DiscoveryResult, wg *sync.WaitGroup) {
	defer wg.Done()

	parsed, err := url.Parse(profileUrl)
	if err != nil {
		log.Printf("Could not parse url=%s err=%s", profileUrl, err)
		out <- DiscoveryResult{
			ScreenName: screenName,
			ProfileURL: profileUrl,
			Error:      err,
		}
		return
	}

	feeds, err := disco.Discover(parsed)
	if err != nil {
		log.Printf("Could not discover url=%s err=%s", profileUrl, err)
		out <- DiscoveryResult{
			ScreenName: screenName,
			ProfileURL: profileUrl,
			Error:      err,
		}
		return
	}

	for _, result := range feeds {
		log.Printf("Discovered %s -> %s", screenName, result.URL.String())
		out <- DiscoveryResult{
			Feed:       result,
			ScreenName: screenName,
			ProfileURL: profileUrl,
		}
	}
}

func discoverParallel(out chan<- DiscoveryResult, friends map[string]string) {
	var wg sync.WaitGroup
	wg.Add(len(friends))
	for screenName, profileUrl := range friends {
		go discoverOne(screenName, profileUrl, out, &wg)
	}
	wg.Wait()
	close(out)
}

func downloadHandler(w http.ResponseWriter, r *http.Request) {
	if err := r.ParseForm(); err != nil {
		log.Printf("Could not parse friend list: %s", err)
		http.Error(w, "Could not parse friend list", http.StatusBadRequest)
		return
	}

	friends := make(map[string]string, len(r.PostForm))
	for key, values := range r.PostForm {
		if len(values) == 1 {
			friends[key] = values[0]
		}
	}

	out := make(chan DiscoveryResult, len(r.PostForm))
	go discoverParallel(out, friends)

	w.Header().Set("Content-Disposition", "attachment; filename=twitter_friends.opml")
	w.Header().Set("Content-Type", "text/xml")
	opmlTemplate.Execute(w, out)
}

func main() {
	r := mux.NewRouter()
	r.HandleFunc("/", homePageHandler)
	r.HandleFunc("/generate", generateHandler)
	r.HandleFunc("/download", downloadHandler)
	r.HandleFunc("/authorize", signin.AuthorizeHandler)
	r.HandleFunc("/oauth_callback", signin.OauthCallbackHandler)
	server := &http.Server{Handler: r}
	port := os.Getenv("SERVER_PORT")
	listener, err := net.Listen("tcp", fmt.Sprintf(":%s", port))
	if nil != err {
		log.Fatalln(err)
	}
	log.Printf("Listening on port %s\n", port)
	if err := server.Serve(listener); nil != err {
		log.Fatalln(err)
	}
}
